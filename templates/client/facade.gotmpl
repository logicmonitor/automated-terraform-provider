// Code generated by go-swagger; DO NOT EDIT.


{{ if .Copyright -}}// {{ comment .Copyright -}}{{ end }}


package {{ .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command


import (
  "net/http"
  "github.com/go-openapi/runtime"
  httptransport "github.com/go-openapi/runtime/client"
  "github.com/go-openapi/swag"
  "github.com/go-openapi/spec"
  "github.com/go-openapi/errors"
  "github.com/go-openapi/runtime"

  strfmt "github.com/go-openapi/strfmt"

  {{ range .DefaultImports }}{{ printf "%q" .}}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)

const (
    // DefaultHost is the default Host
    // found in Meta (info) section of spec file
    DefaultHost string = {{ printf "%#v" .Host }}
    // DefaultBasePath is the default BasePath
    // found in Meta (info) section of spec file
    DefaultBasePath string = {{ printf "%#v" .BasePath }}
)

// DefaultSchees are the default schemes found in Meta (info) section of spec file
var DefaultSchemes = {{ printf "%#v" .Schemes }}

// Config information for {{ pascalize .Name }} client
type Config struct {
	AccessKey     *string
	AccessID      *string
	TransportCfg  *TransportConfig
}

// NewConfig create a new empty client Config
func NewConfig() *Config {
	return &Config{
		TransportCfg: DefaultTransportConfig(),
	}
}

// SetAccessID for the client Config
func (c *Config) SetAccessID(accessID *string) {
  c.AccessID = accessID
}

// SetAccessKey for the client Config
func (c *Config) SetAccessKey(accessKey *string) {
  c.AccessKey = accessKey
}

// SetAccountDomain for the client Config
func (c *Config) SetAccountDomain(accountDomain *string) {
  if c.TransportCfg == nil {
    c.TransportCfg = DefaultTransportConfig()
  }
  domain := *accountDomain
  c.TransportCfg = c.TransportCfg.WithHost(domain)
}

// New creates a new {{ humanize .Name }} client
func New(c *Config) *{{ pascalize .Name }} {
  transport := httptransport.New(c.TransportCfg.Host, c.TransportCfg.BasePath, c.TransportCfg.Schemes)
  authInfo := LMv1Auth(*c.AccessID, *c.AccessKey)

  cli := new({{ pascalize .Name }})
  cli.Transport = transport
  {{ range .OperationGroups }}
  cli.{{ pascalize .Name }} = {{ .Name }}.New(transport, strfmt.Default, authInfo)
  {{ end }}
  return cli
}

// DefaultTransportConfig creates a TransportConfig with the
// default settings taken from the meta section of the spec file.
func DefaultTransportConfig() *TransportConfig {
    return &TransportConfig {
        Host: DefaultHost,
        BasePath: DefaultBasePath,
        Schemes: DefaultSchemes,
    }
}

// TransportConfig contains the transport related info,
// found in the meta section of the spec file.
type TransportConfig struct {
    Host string
    BasePath string
    Schemes []string
}

// WithHost overrides the default host,
// provided by the meta section of the spec file.
func (cfg *TransportConfig) WithHost(host string) *TransportConfig {
    cfg.Host = host
    return cfg
}

// WithBasePath overrides the default basePath,
// provided by the meta section of the spec file.
func (cfg *TransportConfig) WithBasePath(basePath string) *TransportConfig {
    cfg.BasePath = basePath
    return cfg
}

// WithSchemes overrides the default schemes,
// provided by the meta section of the spec file.
func (cfg *TransportConfig) WithSchemes(schemes []string) *TransportConfig {
    cfg.Schemes = schemes
    return cfg
}

// {{ pascalize .Name }} is a client for {{ humanize .Name }}
type {{ pascalize .Name }} struct {
  {{ range .OperationGroups }}
  {{ pascalize .Name }} *{{ snakize .Name }}.Client
  {{ end }}
  Transport runtime.ClientTransport
}


// SetTransport changes the transport on the client and all its subresources
func (c *{{pascalize .Name}}) SetTransport(transport runtime.ClientTransport) {
  c.Transport = transport
  {{ range .OperationGroups }}
  c.{{ pascalize .Name }}.SetTransport(transport)
  {{ end }}
}

//TODO: See if there is a way to move this out of Facade Template and into Main or Provider templates
func LMv1Auth(accessId, accessKey string) runtime.ClientAuthInfoWriter {
	return runtime.ClientAuthInfoWriterFunc(func(r runtime.ClientRequest, _ strfmt.Registry) error {
		// get epoch
		now := time.Now()
		nanos := now.UnixNano()
		epoch := strconv.FormatInt(nanos/1000000, 10)

		// build the signature
		h := hmac.New(sha256.New, []byte(accessKey))
		h.Write([]byte(r.GetMethod() + epoch))

		if r.GetBodyParam() != nil {
			buf := new(bytes.Buffer)
            enc := json.NewEncoder(buf)
            enc.SetEscapeHTML(false)
            _ = enc.Encode(r.GetBodyParam())
            h.Write(buf.Bytes())
		}

		if r.GetFileParam() != nil {
			for _, files := range r.GetFileParam() {
				for i, file := range files {
					buf := bytes.NewBuffer(nil)
					buf.ReadFrom(file)
					h.Write(buf.Bytes())
					file = runtime.NamedReader(file.Name(), bytes.NewReader(buf.Bytes()))
					files[i] = file
				}
			}
		}

		h.Write([]byte(r.GetPath()))
		hexDigest := hex.EncodeToString(h.Sum(nil))
		signature := base64.StdEncoding.EncodeToString([]byte(hexDigest))
		r.SetHeaderParam("Authorization", fmt.Sprintf("LMv1 %s:%s:%s", accessId, signature, epoch))
    //TODO Consider moving this up to terraform template level of config
		return r.SetHeaderParam("X-version", "3")
	})
}
